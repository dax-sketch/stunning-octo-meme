import { PrismaClient, CompanyTier, NotificationType } from '@prisma/client';
import { CompanyModel } from '../models/Company';
import { NotificationService } from './notificationService';

const prisma = new PrismaClient();

export interface TierChangeLog {
  id: string;
  companyId: string;
  oldTier: CompanyTier;
  newTier: CompanyTier;
  reason: 'AUTOMATIC' | 'MANUAL_OVERRIDE';
  changedBy?: string; // User ID for manual changes
  createdAt: Date;
}

export interface TierUpdateResult {
  totalCompanies: number;
  updatedCount: number;
  changes: Array<{
    companyId: string;
    companyName: string;
    oldTier: CompanyTier;
    newTier: CompanyTier;
  }>;
}

export class TierService {
  /**
   * Update all company tiers and log changes
   */
  static async updateAllTiers(): Promise<TierUpdateResult> {
    const companies = await prisma.company.findMany({
      select: {
        id: true,
        name: true,
        startDate: true,
        adSpend: true,
        tier: true,
        createdBy: true
      }
    });

    const changes: TierUpdateResult['changes'] = [];
    let updatedCount = 0;

    for (const company of companies) {
      const newTier = CompanyModel.calculateTier({
        startDate: company.startDate,
        adSpend: company.adSpend
      });

      if (newTier !== company.tier) {
        // Update company tier
        await prisma.company.update({
          where: { id: company.id },
          data: { tier: newTier }
        });

        // Log the tier change
        await this.logTierChange({
          companyId: company.id,
          oldTier: company.tier,
          newTier: newTier,
          reason: 'AUTOMATIC'
        });

        // Create notification for company owner
        await this.createTierChangeNotification(
          company.createdBy,
          company.id,
          company.name,
          company.tier,
          newTier
        );

        changes.push({
          companyId: company.id,
          companyName: company.name,
          oldTier: company.tier,
          newTier: newTier
        });

        updatedCount++;
      }
    }

    return {
      totalCompanies: companies.length,
      updatedCount,
      changes
    };
  }

  /**
   * Manually override a company's tier (admin only)
   */
  static async overrideTier(
    companyId: string,
    newTier: CompanyTier,
    adminUserId: string,
    reason?: string
  ): Promise<void> {
    // Verify admin permissions
    const admin = await prisma.user.findUnique({
      where: { id: adminUserId }
    });

    if (!admin || (admin.role !== 'CEO' && admin.role !== 'MANAGER')) {
      throw new Error('Insufficient permissions to override tier');
    }

    // Get current company data
    const company = await prisma.company.findUnique({
      where: { id: companyId }
    });

    if (!company) {
      throw new Error('Company not found');
    }

    if (company.tier === newTier) {
      throw new Error('Company is already in the specified tier');
    }

    // Update company tier
    await prisma.company.update({
      where: { id: companyId },
      data: { 
        tier: newTier,
        // Add a flag to indicate manual override
        updatedAt: new Date()
      }
    });

    // Log the manual tier change
    await this.logTierChange({
      companyId,
      oldTier: company.tier,
      newTier,
      reason: 'MANUAL_OVERRIDE',
      changedBy: adminUserId,
      notes: reason || null
    });

    // Create notification for company owner (if different from admin)
    if (company.createdBy !== adminUserId) {
      await this.createTierChangeNotification(
        company.createdBy,
        companyId,
        company.name,
        company.tier,
        newTier,
        `Tier manually updated by ${admin.username}`
      );
    }

    // Create notification for admin confirming the change
    await NotificationService.createNotification({
      userId: adminUserId,
      type: 'COMPANY_MILESTONE',
      title: 'Tier Override Completed',
      message: `Successfully updated ${company.name} from ${company.tier} to ${newTier}`,
      scheduledFor: new Date(),
      relatedCompanyId: companyId
    });
  }

  /**
   * Get tier change history for a company
   */
  static async getTierHistory(companyId: string): Promise<any[]> {
    return prisma.tierChangeLog.findMany({
      where: { companyId },
      include: {
        changedByUser: {
          select: {
            id: true,
            username: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    });
  }

  /**
   * Get tier statistics
   */
  static async getTierStatistics(): Promise<{
    distribution: Record<CompanyTier, number>;
    recentChanges: number;
    totalCompanies: number;
  }> {
    // Get tier distribution
    const distribution = await prisma.company.groupBy({
      by: ['tier'],
      _count: {
        tier: true
      }
    });

    const tierCounts = distribution.reduce((acc, item) => {
      acc[item.tier] = item._count.tier;
      return acc;
    }, {} as Record<CompanyTier, number>);

    // Ensure all tiers are represented
    const fullDistribution: Record<CompanyTier, number> = {
      TIER_1: tierCounts.TIER_1 || 0,
      TIER_2: tierCounts.TIER_2 || 0,
      TIER_3: tierCounts.TIER_3 || 0
    };

    // Get recent changes (last 7 days)
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

    const recentChanges = await prisma.tierChangeLog.count({
      where: {
        createdAt: {
          gte: sevenDaysAgo
        }
      }
    });

    const totalCompanies = await prisma.company.count();

    return {
      distribution: fullDistribution,
      recentChanges,
      totalCompanies
    };
  }

  /**
   * Log a tier change
   */
  private static async logTierChange(data: {
    companyId: string;
    oldTier: CompanyTier;
    newTier: CompanyTier;
    reason: 'AUTOMATIC' | 'MANUAL_OVERRIDE';
    changedBy?: string;
    notes?: string;
  }): Promise<void> {
    await prisma.tierChangeLog.create({
      data: {
        companyId: data.companyId,
        oldTier: data.oldTier,
        newTier: data.newTier,
        reason: data.reason,
        changedBy: data.changedBy || null,
        notes: data.notes || null
      }
    });
  }

  /**
   * Create a tier change notification
   */
  private static async createTierChangeNotification(
    userId: string,
    companyId: string,
    companyName: string,
    oldTier: CompanyTier,
    newTier: CompanyTier,
    customMessage?: string
  ): Promise<void> {
    const tierLabels = {
      TIER_1: 'Tier 1 (High Ad Spend)',
      TIER_2: 'Tier 2 (New Company)',
      TIER_3: 'Tier 3 (Low Ad Spend)'
    };

    const message = customMessage || 
      `${companyName} has been moved from ${tierLabels[oldTier]} to ${tierLabels[newTier]}`;

    await NotificationService.createNotification({
      userId,
      type: 'COMPANY_MILESTONE',
      title: 'Company Tier Updated',
      message,
      scheduledFor: new Date(),
      relatedCompanyId: companyId
    });
  }

  /**
   * Check if a user can override tiers
   */
  static async canOverrideTiers(userId: string): Promise<boolean> {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { role: true }
    });

    return user?.role === 'CEO' || user?.role === 'MANAGER';
  }

  /**
   * Get companies that might need tier review
   */
  static async getCompaniesNeedingReview(): Promise<Array<{
    id: string;
    name: string;
    tier: CompanyTier;
    suggestedTier: CompanyTier;
    reason: string;
  }>> {
    const companies = await prisma.company.findMany({
      select: {
        id: true,
        name: true,
        tier: true,
        startDate: true,
        adSpend: true
      }
    });

    const needsReview = [];

    for (const company of companies) {
      const suggestedTier = CompanyModel.calculateTier({
        startDate: company.startDate,
        adSpend: company.adSpend
      });

      if (suggestedTier !== company.tier) {
        let reason = '';
        if (suggestedTier === 'TIER_1') {
          reason = 'High ad spend qualifies for Tier 1';
        } else if (suggestedTier === 'TIER_2') {
          reason = 'Company is still new (< 6 months)';
        } else {
          reason = 'Company is old with low ad spend';
        }

        needsReview.push({
          id: company.id,
          name: company.name,
          tier: company.tier,
          suggestedTier,
          reason
        });
      }
    }

    return needsReview;
  }
}